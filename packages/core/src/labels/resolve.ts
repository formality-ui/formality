// @formality-ui/core - Label Resolution
// Pure functions for resolving field labels
// ZERO framework dependencies

import type { FieldConfig } from '../types';

/**
 * Convert a camelCase or PascalCase field name to a human-readable label
 *
 * @param fieldName - The field name to humanize
 * @returns Human-readable label
 *
 * @example
 * humanizeLabel("clientContact") // → "Client Contact"
 * humanizeLabel("minGrossMarginPercent") // → "Min Gross Margin Percent"
 * humanizeLabel("CCIP/CCOP") // → "CCIP/CCOP" (preserved)
 * humanizeLabel("firstName") // → "First Name"
 * humanizeLabel("HTMLParser") // → "Html Parser"
 * humanizeLabel("userID") // → "User Id"
 */
export function humanizeLabel(fieldName: string): string {
  // Empty string
  if (!fieldName) {
    return '';
  }

  // Handle special characters (preserve as-is with first letter capitalized)
  if (/[^a-zA-Z0-9]/.test(fieldName)) {
    // Contains special chars - might be intentional (e.g., "CCIP/CCOP")
    // Just capitalize first letter if needed
    return fieldName.charAt(0).toUpperCase() + fieldName.slice(1);
  }

  // Split on camelCase boundaries
  // "clientContact" → ["client", "Contact"]
  // "HTMLParser" → ["HTML", "Parser"]
  const words = fieldName
    .replace(/([a-z])([A-Z])/g, '$1 $2') // camelCase: clientContact → client Contact
    .replace(/([A-Z]+)([A-Z][a-z])/g, '$1 $2') // acronyms: HTMLParser → HTML Parser
    .split(' ');

  // Capitalize each word
  return words
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
}

/**
 * Resolve the label for a field
 *
 * Priority order (highest to lowest):
 * 1. Component prop (label from JSX props)
 * 2. Field config props.label
 * 3. Evaluated selectProps.label
 * 4. Field config label
 * 5. Field config title (legacy alias)
 * 6. Auto-generated from field name
 *
 * @param fieldName - Field name
 * @param fieldConfig - Field configuration
 * @param evaluatedSelectProps - Pre-evaluated selectProps
 * @param componentProps - Props from JSX
 * @returns Resolved label string
 */
export function resolveLabel(
  fieldName: string,
  fieldConfig?: FieldConfig,
  evaluatedSelectProps?: Record<string, unknown>,
  componentProps?: Record<string, unknown>
): string {
  // Priority 1: Component prop
  if (componentProps?.label !== undefined) {
    return String(componentProps.label);
  }

  // Priority 2: Field config props.label
  if (fieldConfig?.props?.label !== undefined) {
    return String(fieldConfig.props.label);
  }

  // Priority 3: Evaluated selectProps.label
  if (evaluatedSelectProps?.label !== undefined) {
    return String(evaluatedSelectProps.label);
  }

  // Priority 4: Field config label
  if (fieldConfig?.label !== undefined) {
    return fieldConfig.label;
  }

  // Priority 5: Field config title (legacy alias)
  if (fieldConfig?.title !== undefined) {
    return fieldConfig.title;
  }

  // Priority 6: Auto-generate from field name
  return humanizeLabel(fieldName);
}

/**
 * Resolve the title for a form
 *
 * @param formTitle - Static form title
 * @param evaluatedSelectTitle - Pre-evaluated selectTitle
 * @returns Resolved title string or undefined
 */
export function resolveFormTitle(
  formTitle?: string,
  evaluatedSelectTitle?: unknown
): string | undefined {
  // Evaluated selectTitle takes precedence
  if (evaluatedSelectTitle !== undefined && evaluatedSelectTitle !== null) {
    return String(evaluatedSelectTitle);
  }

  // Static title
  return formTitle;
}

/**
 * Check if a label is auto-generated (matches the humanized field name)
 *
 * @param fieldName - Field name
 * @param label - Current label
 * @returns true if label appears to be auto-generated
 */
export function isAutoGeneratedLabel(fieldName: string, label: string): boolean {
  return humanizeLabel(fieldName) === label;
}

/**
 * Create a label with a unit suffix
 *
 * @param baseLabel - Base label text
 * @param unit - Unit to append (e.g., '%', '$', 'kg')
 * @returns Label with unit in parentheses
 *
 * @example
 * createLabelWithUnit("Min Gross Margin", "%") // → "Min Gross Margin (%)"
 * createLabelWithUnit("Weight", "kg") // → "Weight (kg)"
 */
export function createLabelWithUnit(baseLabel: string, unit: string): string {
  return `${baseLabel} (${unit})`;
}

/**
 * Extract the base label and unit from a label with unit suffix
 *
 * @param label - Label potentially containing unit
 * @returns Object with base label and optional unit
 *
 * @example
 * parseLabelWithUnit("Min Gross Margin (%)") // → { base: "Min Gross Margin", unit: "%" }
 * parseLabelWithUnit("Client Contact") // → { base: "Client Contact", unit: undefined }
 */
export function parseLabelWithUnit(label: string): {
  base: string;
  unit?: string;
} {
  const match = label.match(/^(.+)\s*\(([^)]+)\)$/);
  if (match) {
    return {
      base: match[1].trim(),
      unit: match[2],
    };
  }
  return { base: label };
}

/**
 * Sort fields by their order property
 *
 * @param fieldNames - Array of field names
 * @param fieldConfigs - Map of field configs
 * @returns Sorted array of field names
 */
export function sortFieldsByOrder(
  fieldNames: string[],
  fieldConfigs: Record<string, FieldConfig>
): string[] {
  return [...fieldNames].sort((a, b) => {
    const orderA = fieldConfigs[a]?.order ?? Infinity;
    const orderB = fieldConfigs[b]?.order ?? Infinity;
    return orderA - orderB;
  });
}

/**
 * Get fields that are not in the declared set
 *
 * @param allFields - All field names from config
 * @param declaredFields - Set of explicitly declared field names
 * @returns Array of unused field names
 */
export function getUnusedFields(
  allFields: string[],
  declaredFields: Set<string>
): string[] {
  return allFields.filter((name) => !declaredFields.has(name));
}

/**
 * Get ordered unused fields
 *
 * @param allFields - All field names from config
 * @param declaredFields - Set of explicitly declared field names
 * @param fieldConfigs - Map of field configs
 * @returns Sorted array of unused field names
 */
export function getOrderedUnusedFields(
  allFields: string[],
  declaredFields: Set<string>,
  fieldConfigs: Record<string, FieldConfig>
): string[] {
  const unused = getUnusedFields(allFields, declaredFields);
  return sortFieldsByOrder(unused, fieldConfigs);
}
