import { describe, it, expect } from 'vitest';
import {
  humanizeLabel,
  resolveLabel,
  resolveFormTitle,
  isAutoGeneratedLabel,
  createLabelWithUnit,
  parseLabelWithUnit,
  sortFieldsByOrder,
  getUnusedFields,
  getOrderedUnusedFields,
} from '../index';
import type { FieldConfig } from '../index';

describe('Labels Module', () => {
  describe('humanizeLabel', () => {
    it('should convert camelCase to Title Case', () => {
      expect(humanizeLabel('clientContact')).toBe('Client Contact');
      expect(humanizeLabel('firstName')).toBe('First Name');
      expect(humanizeLabel('lastName')).toBe('Last Name');
    });

    it('should handle multi-word camelCase', () => {
      expect(humanizeLabel('minGrossMarginPercent')).toBe(
        'Min Gross Margin Percent'
      );
      expect(humanizeLabel('maxBillRateDollars')).toBe('Max Bill Rate Dollars');
    });

    it('should handle acronyms', () => {
      expect(humanizeLabel('userID')).toBe('User Id');
      expect(humanizeLabel('HTMLParser')).toBe('Html Parser');
    });

    it('should handle simple words', () => {
      expect(humanizeLabel('client')).toBe('Client');
      expect(humanizeLabel('signed')).toBe('Signed');
    });

    it('should preserve special characters', () => {
      expect(humanizeLabel('CCIP/CCOP')).toBe('CCIP/CCOP');
      expect(humanizeLabel('field-name')).toBe('Field-name');
    });

    it('should handle empty string', () => {
      expect(humanizeLabel('')).toBe('');
    });

    it('should handle PascalCase', () => {
      expect(humanizeLabel('ClientContact')).toBe('Client Contact');
    });
  });

  describe('resolveLabel', () => {
    it('should use component prop first', () => {
      expect(
        resolveLabel('field', { label: 'Config Label' }, undefined, {
          label: 'Component Label',
        })
      ).toBe('Component Label');
    });

    it('should use field config props.label', () => {
      expect(
        resolveLabel('field', { props: { label: 'Props Label' } })
      ).toBe('Props Label');
    });

    it('should use evaluated selectProps.label', () => {
      expect(
        resolveLabel('field', {}, { label: 'Select Props Label' })
      ).toBe('Select Props Label');
    });

    it('should use field config label', () => {
      expect(resolveLabel('field', { label: 'Config Label' })).toBe(
        'Config Label'
      );
    });

    it('should use field config title (legacy)', () => {
      expect(resolveLabel('field', { title: 'Title Label' })).toBe(
        'Title Label'
      );
    });

    it('should auto-generate from field name', () => {
      expect(resolveLabel('clientContact')).toBe('Client Contact');
      expect(resolveLabel('firstName', {})).toBe('First Name');
    });
  });

  describe('resolveFormTitle', () => {
    it('should prefer evaluated selectTitle', () => {
      expect(resolveFormTitle('Static Title', 'Dynamic Title')).toBe(
        'Dynamic Title'
      );
    });

    it('should use static title', () => {
      expect(resolveFormTitle('Static Title')).toBe('Static Title');
    });

    it('should handle undefined', () => {
      expect(resolveFormTitle()).toBeUndefined();
      expect(resolveFormTitle(undefined, null)).toBeUndefined();
    });
  });

  describe('isAutoGeneratedLabel', () => {
    it('should detect auto-generated labels', () => {
      expect(isAutoGeneratedLabel('clientContact', 'Client Contact')).toBe(true);
      expect(isAutoGeneratedLabel('firstName', 'First Name')).toBe(true);
    });

    it('should detect custom labels', () => {
      expect(isAutoGeneratedLabel('clientContact', 'Customer')).toBe(false);
      expect(isAutoGeneratedLabel('firstName', 'Given Name')).toBe(false);
    });
  });

  describe('createLabelWithUnit', () => {
    it('should append unit in parentheses', () => {
      expect(createLabelWithUnit('Min Gross Margin', '%')).toBe(
        'Min Gross Margin (%)'
      );
      expect(createLabelWithUnit('Weight', 'kg')).toBe('Weight (kg)');
      expect(createLabelWithUnit('Price', '$')).toBe('Price ($)');
    });
  });

  describe('parseLabelWithUnit', () => {
    it('should extract base and unit', () => {
      expect(parseLabelWithUnit('Min Gross Margin (%)')).toEqual({
        base: 'Min Gross Margin',
        unit: '%',
      });
      expect(parseLabelWithUnit('Weight (kg)')).toEqual({
        base: 'Weight',
        unit: 'kg',
      });
    });

    it('should handle labels without unit', () => {
      expect(parseLabelWithUnit('Client Contact')).toEqual({
        base: 'Client Contact',
      });
    });

    it('should handle labels with nested parentheses', () => {
      // Takes last parentheses as unit
      expect(parseLabelWithUnit('Field (note) (unit)')).toEqual({
        base: 'Field (note)',
        unit: 'unit',
      });
    });
  });

  describe('Field Ordering', () => {
    const fieldConfigs: Record<string, FieldConfig> = {
      first: { order: 1 },
      second: { order: 2 },
      third: { order: 3 },
      noOrder: {},
    };

    describe('sortFieldsByOrder', () => {
      it('should sort by order property', () => {
        const fields = ['third', 'first', 'second'];
        expect(sortFieldsByOrder(fields, fieldConfigs)).toEqual([
          'first',
          'second',
          'third',
        ]);
      });

      it('should put fields without order last', () => {
        const fields = ['noOrder', 'first', 'second'];
        expect(sortFieldsByOrder(fields, fieldConfigs)).toEqual([
          'first',
          'second',
          'noOrder',
        ]);
      });

      it('should preserve original order for equal order values', () => {
        const configs: Record<string, FieldConfig> = {
          a: { order: 1 },
          b: { order: 1 },
          c: { order: 1 },
        };
        const fields = ['a', 'b', 'c'];
        const sorted = sortFieldsByOrder(fields, configs);
        // All have same order, should maintain relative order
        expect(sorted.length).toBe(3);
      });

      it('should handle negative orders', () => {
        const configs: Record<string, FieldConfig> = {
          first: { order: -10 },
          second: { order: 0 },
          third: { order: 10 },
        };
        expect(sortFieldsByOrder(['third', 'first', 'second'], configs)).toEqual([
          'first',
          'second',
          'third',
        ]);
      });
    });

    describe('getUnusedFields', () => {
      it('should return fields not in declared set', () => {
        const allFields = ['a', 'b', 'c', 'd'];
        const declared = new Set(['a', 'c']);

        expect(getUnusedFields(allFields, declared)).toEqual(['b', 'd']);
      });

      it('should return empty array when all declared', () => {
        const allFields = ['a', 'b'];
        const declared = new Set(['a', 'b']);

        expect(getUnusedFields(allFields, declared)).toEqual([]);
      });
    });

    describe('getOrderedUnusedFields', () => {
      it('should return sorted unused fields', () => {
        const allFields = ['first', 'second', 'third', 'noOrder'];
        const declared = new Set(['first']);

        expect(
          getOrderedUnusedFields(allFields, declared, fieldConfigs)
        ).toEqual(['second', 'third', 'noOrder']);
      });
    });
  });
});
